"""Exploit worker - crafts payloads and PoC code using code-specialized LLM."""

import json
import time
import yaml
from pathlib import Path

from src.workers.celery_app import app
from src.models.vllm_client import get_llm
from src.database.models import FindingDB, HypothesisDB, WorkerLogDB
from src.database.redis_manager import TaskQueue
from src.services.browser import run_curl


PAYLOADS_DIR = Path(__file__).parent.parent.parent / "data" / "payloads"


def _load_payloads(category: str) -> list:
    path = PAYLOADS_DIR / f"{category}.yaml"
    if path.exists():
        with open(path) as f:
            data = yaml.safe_load(f)
            return data.get("payloads", []) if isinstance(data, dict) else data
    return []


@app.task(name="src.workers.exploit.craft_exploit", bind=True, queue="exploit")
def craft_exploit(self, hunt_id: int, target_id: int, hypothesis: dict):
    """Generate exploit payload for a hypothesis card."""
    start = time.time()
    llm = get_llm()

    category = hypothesis.get("category", "unknown")
    relevant_payloads = _load_payloads(category)[:20]

    prompt = f"""Craft an exploit for this vulnerability hypothesis.

## Hypothesis
{json.dumps(hypothesis, indent=2)}

## Available payload templates for {category}:
{json.dumps(relevant_payloads[:10], indent=2)}

## Requirements
1. Generate the EXACT curl command to test this vulnerability
2. Include all necessary headers, cookies, parameters
3. If WAF is likely, include bypass variants
4. Provide a Python PoC script if the attack requires multiple steps

Return JSON:
{{
  "exploit_type": "{category}",
  "primary_payload": "the main payload",
  "curl_command": "complete curl command",
  "bypass_variants": ["alternative payloads for WAF bypass"],
  "poc_script": "Python script if multi-step",
  "expected_response": "what success looks like",
  "impact": "what attacker achieves"
}}"""

    response = llm.chat_json("exploit", [{"role": "user", "content": prompt}],
                             temperature=0.4, max_tokens=4096)

    duration = time.time() - start
    WorkerLogDB.log("exploit", "deepseek-7b", "craft_exploit", hunt_id=hunt_id,
                    input_summary=hypothesis.get("hypothesis", "")[:200],
                    output_summary=f"Exploit crafted: {response.get('exploit_type', 'unknown')}",
                    duration_seconds=duration)

    return {
        "status": "complete",
        "hypothesis_id": hypothesis.get("id"),
        "exploit": response,
        "duration": duration,
    }


@app.task(name="src.workers.exploit.test_hypothesis_browser", bind=True, queue="exploit")
def test_hypothesis_browser(self, hunt_id: int, target_id: int, hypothesis: dict, domain: str):
    """Test a hypothesis using browser automation."""
    import asyncio
    from src.services.browser import BrowserService

    start = time.time()
    llm = get_llm()

    # Get exploit details from LLM
    exploit_result = craft_exploit(hunt_id, target_id, hypothesis)
    exploit = exploit_result.get("exploit", {})

    test_method = hypothesis.get("test_method", "curl")

    if test_method in ("curl", "both"):
        curl_cmd = exploit.get("curl_command", "")
        if curl_cmd:
            curl_result = run_curl(curl_cmd)

            # Ask LLM to analyze the result
            analysis_prompt = f"""Analyze this curl response for vulnerability evidence.

Hypothesis: {hypothesis.get('hypothesis')}
Expected: {exploit.get('expected_response')}
Curl command: {curl_cmd}

Response (stdout):
{curl_result['stdout'][:3000]}

Response (stderr):
{curl_result['stderr'][:500]}

Return JSON:
{{
  "vulnerable": true/false,
  "evidence": "specific evidence from response",
  "confidence": "high|medium|low",
  "finding_type": "vulnerability type if found",
  "severity": "critical|high|medium|low|info"
}}"""

            analysis = llm.chat_json("validator", [{"role": "user", "content": analysis_prompt}],
                                     temperature=0.1, max_tokens=1024)

            if analysis.get("vulnerable"):
                FindingDB.create(
                    hunt_id=hunt_id, target_id=target_id,
                    finding_type=analysis.get("finding_type", hypothesis.get("category", "unknown")),
                    severity=analysis.get("severity", "medium"),
                    title=hypothesis.get("hypothesis", "Unknown finding"),
                    url=hypothesis.get("payload", ""),
                    payload=exploit.get("primary_payload", ""),
                    curl_command=curl_cmd,
                    evidence={"curl_response": curl_result["stdout"][:2000], "analysis": analysis},
                    discovered_by="exploit-worker",
                )

                # Store cross-target pattern
                TaskQueue.store_cross_target_pattern({
                    "finding_type": analysis.get("finding_type"),
                    "category": hypothesis.get("category"),
                    "technique": hypothesis.get("hypothesis"),
                    "domain": domain,
                })

                duration = time.time() - start
                return {"status": "finding", "analysis": analysis, "duration": duration}

    duration = time.time() - start
    HypothesisDB.update(hypothesis.get("db_id", 0), status="tested", result="no_finding")
    return {"status": "no_finding", "duration": duration}


@app.task(name="src.workers.exploit.batch_test_payloads", bind=True, queue="exploit")
def batch_test_payloads(self, hunt_id: int, target_id: int, url: str,
                        param: str, payload_category: str):
    """Test a batch of payloads against a specific URL/parameter."""
    payloads = _load_payloads(payload_category)
    results = []

    for payload_entry in payloads[:30]:
        payload = payload_entry if isinstance(payload_entry, str) else payload_entry.get("payload", "")
        if not payload:
            continue

        test_url = f"{url}?{param}={payload}" if "?" not in url else f"{url}&{param}={payload}"
        curl_result = run_curl(f'curl -s -m 10 "{test_url}"')

        results.append({
            "payload": payload,
            "status_code": curl_result.get("returncode"),
            "response_length": len(curl_result.get("stdout", "")),
            "response_preview": curl_result.get("stdout", "")[:200],
        })

    return {"status": "complete", "tested": len(results), "results": results}
